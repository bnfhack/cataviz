{"version":3,"file":"graphology.layout.noverlap.min.js","mappings":"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","sources":["webpack://GraphologyLayoutNoverlap/./layout-noverlap/defaults.js","webpack://GraphologyLayoutNoverlap/./layout-noverlap/helpers.js","webpack://GraphologyLayoutNoverlap/./layout-noverlap/index.js","webpack://GraphologyLayoutNoverlap/./layout-noverlap/iterate.js","webpack://GraphologyLayoutNoverlap/./layout-noverlap/node_modules/graphology-utils/is-graph.js","webpack://GraphologyLayoutNoverlap/webpack/bootstrap","webpack://GraphologyLayoutNoverlap/webpack/startup"],"sourcesContent":["/**\n * Graphology Noverlap Layout Default Settings\n * ============================================\n */\nmodule.exports = {\n  gridSize: 20,\n  margin: 5,\n  expansion: 1.1,\n  ratio: 1.0,\n  speed: 3\n};\n","/**\n * Graphology Noverlap Helpers\n * ============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 3;\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function (settings) {\n  if (\n    ('gridSize' in settings && typeof settings.gridSize !== 'number') ||\n    settings.gridSize <= 0\n  )\n    return {message: 'the `gridSize` setting should be a positive number.'};\n\n  if (\n    ('margin' in settings && typeof settings.margin !== 'number') ||\n    settings.margin < 0\n  )\n    return {\n      message: 'the `margin` setting should be 0 or a positive number.'\n    };\n\n  if (\n    ('expansion' in settings && typeof settings.expansion !== 'number') ||\n    settings.expansion <= 0\n  )\n    return {message: 'the `expansion` setting should be a positive number.'};\n\n  if (\n    ('ratio' in settings && typeof settings.ratio !== 'number') ||\n    settings.ratio <= 0\n  )\n    return {message: 'the `ratio` setting should be a positive number.'};\n\n  if (\n    ('speed' in settings && typeof settings.speed !== 'number') ||\n    settings.speed <= 0\n  )\n    return {message: 'the `speed` setting should be a positive number.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for the given graph's nodes.\n *\n * @param  {Graph}        graph   - Target graph.\n * @param  {function}     reducer - Node reducer function.\n * @return {Float32Array}         - The node matrix.\n */\nexports.graphToByteArray = function (graph, reducer) {\n  var order = graph.order;\n\n  var matrix = new Float32Array(order * PPN);\n\n  var j = 0;\n\n  graph.forEachNode(function (node, attr) {\n    if (typeof reducer === 'function') attr = reducer(node, attr);\n\n    matrix[j] = attr.x;\n    matrix[j + 1] = attr.y;\n    matrix[j + 2] = attr.size || 1;\n    j += PPN;\n  });\n\n  return matrix;\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n * @param {function}     reducer    - Reducing function.\n */\nexports.assignLayoutChanges = function (graph, NodeMatrix, reducer) {\n  var i = 0;\n\n  graph.forEachNode(function (node) {\n    var pos = {\n      x: NodeMatrix[i],\n      y: NodeMatrix[i + 1]\n    };\n\n    if (typeof reducer === 'function') pos = reducer(node, pos);\n\n    graph.mergeNodeAttributes(node, pos);\n\n    i += PPN;\n  });\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}        graph      - Target graph.\n * @param  {Float32Array} NodeMatrix - Node matrix.\n * @param  {function}     reducer    - Reducing function.\n * @return {object}                  - Map to node positions.\n */\nexports.collectLayoutChanges = function (graph, NodeMatrix, reducer) {\n  var positions = {};\n\n  var i = 0;\n\n  graph.forEachNode(function (node) {\n    var pos = {\n      x: NodeMatrix[i],\n      y: NodeMatrix[i + 1]\n    };\n\n    if (typeof reducer === 'function') pos = reducer(node, pos);\n\n    positions[node] = pos;\n\n    i += PPN;\n  });\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(\n    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})\n  );\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n","/**\n * Graphology Noverlap Layout\n * ===========================\n *\n * Library endpoint.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar iterate = require('./iterate.js');\nvar helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\nvar DEFAULT_MAX_ITERATIONS = 500;\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign       - Whether to assign positions.\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - If number, params.maxIterations, else:\n * @param  {number}          maxIterations - Maximum number of iterations.\n * @param  {object}          [settings] - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-noverlap: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {maxIterations: params};\n  else params = params || {};\n\n  var maxIterations = params.maxIterations || DEFAULT_MAX_ITERATIONS;\n\n  if (typeof maxIterations !== 'number' || maxIterations <= 0)\n    throw new Error(\n      'graphology-layout-force: you should provide a positive number of maximum iterations.'\n    );\n\n  // Validating settings\n  var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings),\n    validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error('graphology-layout-noverlap: ' + validationError.message);\n\n  // Building matrices\n  var matrix = helpers.graphToByteArray(graph, params.inputReducer),\n    converged = false,\n    i;\n\n  // Iterating\n  for (i = 0; i < maxIterations && !converged; i++)\n    converged = iterate(settings, matrix).converged;\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrix, params.outputReducer);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrix, params.outputReducer);\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\n\nmodule.exports = synchronousLayout;\n","/**\n * Graphology Noverlap Iteration\n * ==============================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0,\n  NODE_Y = 1,\n  NODE_SIZE = 2;\n\n/**\n * Constants.\n */\nvar PPN = 3;\n\n/**\n * Helpers.\n */\nfunction hashPair(a, b) {\n  return a + 'ยง' + b;\n}\n\nfunction jitter() {\n  return 0.01 * (0.5 - Math.random());\n}\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix) {\n  // Caching options\n  var margin = options.margin;\n  var ratio = options.ratio;\n  var expansion = options.expansion;\n  var gridSize = options.gridSize; // TODO: decrease grid size when few nodes?\n  var speed = options.speed;\n\n  // Generic iteration variables\n  var i, j, x, y, l, size;\n  var converged = true;\n\n  var length = NodeMatrix.length;\n  var order = (length / PPN) | 0;\n\n  var deltaX = new Float32Array(order);\n  var deltaY = new Float32Array(order);\n\n  // Finding the extents of our space\n  var xMin = Infinity;\n  var yMin = Infinity;\n  var xMax = -Infinity;\n  var yMax = -Infinity;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    xMin = Math.min(xMin, x - size);\n    xMax = Math.max(xMax, x + size);\n    yMin = Math.min(yMin, y - size);\n    yMax = Math.max(yMax, y + size);\n  }\n\n  var width = xMax - xMin;\n  var height = yMax - yMin;\n  var xCenter = (xMin + xMax) / 2;\n  var yCenter = (yMin + yMax) / 2;\n\n  xMin = xCenter - (expansion * width) / 2;\n  xMax = xCenter + (expansion * width) / 2;\n  yMin = yCenter - (expansion * height) / 2;\n  yMax = yCenter + (expansion * height) / 2;\n\n  // Building grid\n  var grid = new Array(gridSize * gridSize),\n    gridLength = grid.length,\n    c;\n\n  for (c = 0; c < gridLength; c++) grid[c] = [];\n\n  var nxMin, nxMax, nyMin, nyMax;\n  var xMinBox, xMaxBox, yMinBox, yMaxBox;\n\n  var col, row;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    nxMin = x - size;\n    nxMax = x + size;\n    nyMin = y - size;\n    nyMax = y + size;\n\n    xMinBox = Math.floor((gridSize * (nxMin - xMin)) / (xMax - xMin));\n    xMaxBox = Math.floor((gridSize * (nxMax - xMin)) / (xMax - xMin));\n    yMinBox = Math.floor((gridSize * (nyMin - yMin)) / (yMax - yMin));\n    yMaxBox = Math.floor((gridSize * (nyMax - yMin)) / (yMax - yMin));\n\n    for (col = xMinBox; col <= xMaxBox; col++) {\n      for (row = yMinBox; row <= yMaxBox; row++) {\n        grid[col * gridSize + row].push(i);\n      }\n    }\n  }\n\n  // Computing collisions\n  var cell;\n\n  var collisions = new Set();\n\n  var n1, n2, x1, x2, y1, y2, s1, s2, h;\n\n  var xDist, yDist, dist, collision;\n\n  for (c = 0; c < gridLength; c++) {\n    cell = grid[c];\n\n    for (i = 0, l = cell.length; i < l; i++) {\n      n1 = cell[i];\n\n      x1 = NodeMatrix[n1 + NODE_X];\n      y1 = NodeMatrix[n1 + NODE_Y];\n      s1 = NodeMatrix[n1 + NODE_SIZE];\n\n      for (j = i + 1; j < l; j++) {\n        n2 = cell[j];\n        h = hashPair(n1, n2);\n\n        if (gridLength > 1 && collisions.has(h)) continue;\n\n        if (gridLength > 1) collisions.add(h);\n\n        x2 = NodeMatrix[n2 + NODE_X];\n        y2 = NodeMatrix[n2 + NODE_Y];\n        s2 = NodeMatrix[n2 + NODE_SIZE];\n\n        xDist = x2 - x1;\n        yDist = y2 - y1;\n        dist = Math.sqrt(xDist * xDist + yDist * yDist);\n        collision = dist < s1 * ratio + margin + (s2 * ratio + margin);\n\n        if (collision) {\n          converged = false;\n\n          n2 = (n2 / PPN) | 0;\n\n          if (dist > 0) {\n            deltaX[n2] += (xDist / dist) * (1 + s1);\n            deltaY[n2] += (yDist / dist) * (1 + s1);\n          } else {\n            // Nodes are on the exact same spot, we need to jitter a bit\n            deltaX[n2] += width * jitter();\n            deltaY[n2] += height * jitter();\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0, j = 0; i < length; i += PPN, j++) {\n    NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;\n    NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;\n  }\n\n  return {converged: converged};\n};\n","/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(881);\n"],"names":["module","exports","gridSize","margin","expansion","ratio","speed","validateSettings","settings","message","graphToByteArray","graph","reducer","order","matrix","Float32Array","j","forEachNode","node","attr","x","y","size","assignLayoutChanges","NodeMatrix","i","pos","mergeNodeAttributes","collectLayoutChanges","positions","createWorker","fn","xURL","window","URL","webkitURL","code","toString","objectUrl","createObjectURL","Blob","type","worker","Worker","revokeObjectURL","isGraph","require","iterate","helpers","DEFAULT_SETTINGS","abstractSynchronousLayout","assign","params","Error","maxIterations","Object","validationError","inputReducer","converged","outputReducer","synchronousLayout","bind","jitter","Math","random","options","l","length","deltaX","deltaY","xMin","Infinity","yMin","xMax","yMax","min","max","width","height","xCenter","yCenter","c","nxMin","nxMax","nyMin","nyMax","xMinBox","xMaxBox","yMinBox","yMaxBox","col","row","cell","grid","Array","gridLength","floor","push","n1","n2","x1","x2","y1","y2","s1","s2","h","xDist","yDist","dist","collisions","Set","has","add","sqrt","value","addUndirectedEdgeWithKey","dropNode","multi","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}